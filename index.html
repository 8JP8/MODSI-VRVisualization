<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BabiaXR - Gr√°fico 3D</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.3/dist/aframe-environment-component.min.js"></script>
    <script src="https://unpkg.com/aframe-text-geometry-component@0.5.1/dist/aframe-text-geometry-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/babiaxr/aframe-babia-components@master/dist/aframe-babia-components.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/babiaxr/aframe-babia-components@master/dist/aframe-babia-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* Prevent scrollbars from A-Frame canvas */
        }
        
        /* Room selector UI */
        .room-selector {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            color: white;
            z-index: 1000;
            min-width: 280px; /* Increased min-width slightly */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        
        .room-selector.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
        }
        
        .room-selector h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            font-weight: 600;
            color: #4CAF50; /* Babia Green */
        }
        
        .room-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .room-input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
        }
        
        .room-input:focus {
            border-color: #4CAF50;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .room-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .room-btn {
            padding: 8px 16px;
            background: #4CAF50;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex; /* For spinner alignment */
            align-items: center; /* For spinner alignment */
            justify-content: center; /* For spinner alignment */
        }

        .room-btn:disabled {
            background: #aaa;
            cursor: not-allowed;
        }
        
        .room-btn:hover:not(:disabled) {
            background: #45a049;
            transform: translateY(-1px);
        }
        
        .room-btn:active:not(:disabled) {
            transform: translateY(0px);
        }
        
        .room-status {
            font-size: 12px;
            margin-top: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            text-align: center;
            display: flex; /* For spinner alignment */
            align-items: center; /* For spinner alignment */
            justify-content: center; /* For spinner alignment */
        }
        
        .room-status.success {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }
        
        .room-status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }
        
        .room-status.loading {
            background: rgba(33, 150, 243, 0.2);
            color: #2196F3;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }
        
        /* Minimize button */
        .minimize-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s ease;
            line-height: 1; /* Ensure text is centered vertically */
        }
        
        .minimize-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Collapsed state */
        .room-selector.collapsed {
            padding: 10px;
            min-width: auto;
            cursor: pointer;
            width: auto; /* Adjust width when collapsed */
        }
        
        .room-selector.collapsed .room-content {
            display: none;
        }
        
        .room-selector.collapsed .minimize-btn {
            display: none; /* Hide minimize button when collapsed, as clicking the panel expands it */
        }
        
        .collapsed-indicator {
            display: none;
            font-size: 12px;
            color: #4CAF50;
        }
        
        .room-selector.collapsed .collapsed-indicator {
            display: block;
        }
        
        /* Hide in VR/fullscreen is handled by JS, but this can be a fallback */
        .a-fullscreen .room-selector { /* A-Frame adds .a-fullscreen to body */
             display: none !important;
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff; /* Spinner color for button */
            animation: spin 1s ease-in-out infinite;
            margin-right: 6px;
        }
        .room-status .spinner { /* Spinner color for status message */
             border-top-color: #2196F3;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <a-scene background="color: #ECECEC" cursor="rayOrigin: mouse; fuse: false" raycaster="objects: .clickable">
        <a-entity environment="preset: default; groundColor: #445; groundTexture: walk;"></a-entity>
        
        <a-assets>
            <a-asset-item id="optimerBoldFont" src="https://rawgit.com/mrdoob/three.js/dev/examples/fonts/optimer_bold.typeface.json"></a-asset-item>
        </a-assets>

        <!-- Loading indicator -->
        <a-entity id="loading-indicator" position="0 3 -5" visible="false">
            <a-text value="Carregando dados..." align="center" color="#FFFFFF" width="8"></a-text>
            <a-text id="room-info-text" value="" position="0 -1 0" align="center" color="#CCCCCC" width="6"></a-text>
        </a-entity>

        <!-- Error indicator -->
        <a-entity id="error-indicator" position="0 3 -5" visible="false">
            <a-text id="error-main-text" value="O carregamento da sala falhou" align="center" color="#FF6B6B" width="10"></a-text>
            <a-text id="error-sub-text" value="Verifique o c√≥digo da sala e tente novamente" position="0 -1.5 0" align="center" color="#FFAA5A" width="8"></a-text>
            <a-text id="retry-text" value="Clique aqui para tentar novamente" position="0 -3 0" align="center" color="#4CAF50" width="7" class="clickable" visible="false"></a-text>
        </a-entity>

        <!-- Ponto de inser√ß√£o de gr√°ficos -->
        <a-entity id="charts-root"></a-entity>

        <!-- C√¢mera -->
        <a-entity movement-controls="fly: true" position="-3 5 20">
            <a-entity camera position="0 0 0" look-controls></a-entity>
            <!-- Removed cursor from camera, handled by scene's cursor component -->
            <a-entity laser-controls="hand: right" raycaster="objects: .clickable"></a-entity>
        </a-entity>
    </a-scene>

    <!-- Room Selector UI -->
    <div class="room-selector" id="roomSelectorUI">
        <button class="minimize-btn" id="minimizeBtn">‚àí</button>
        <div class="collapsed-indicator">Sala: <span id="currentRoomDisplay">LD5RU</span></div>
        <div class="room-content">
            <h3>üè† Seletor de Sala</h3>
            <div class="room-input-group">
                <input type="text" class="room-input" id="roomCodeInput" placeholder="C√≥digo da sala (ex: LD5RU)" maxlength="10">
                <button class="room-btn" id="connectRoomBtn">Conectar</button>
            </div>
            <div class="room-status" id="roomStatusMessage" style="display: none;"></div>
        </div>
    </div>

    <script>
        const chartsRoot = document.getElementById('charts-root');
        const loadingIndicatorEl = document.getElementById('loading-indicator');
        const errorIndicatorEl = document.getElementById('error-indicator');
        const retryTextEl = document.getElementById('retry-text');

        // Room selector UI elements
        const roomSelectorUI = document.getElementById('roomSelectorUI');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const connectRoomBtn = document.getElementById('connectRoomBtn');
        const roomStatusMessage = document.getElementById('roomStatusMessage');
        const minimizeBtn = document.getElementById('minimizeBtn');
        const currentRoomDisplay = document.getElementById('currentRoomDisplay');
        const roomInfoTextEl = document.getElementById('room-info-text');
        const errorMainTextEl = document.getElementById('error-main-text');
        const errorSubTextEl = document.getElementById('error-sub-text');


        // API Configuration
        const API_BASE_URL = 'https://modsi-api-ffhhfgecfdehhscv.spaincentral-01.azurewebsites.net/api/Room/Get/';
        const API_CODE = 'z4tKbNFdaaXzHZ4ayn9pRQokNWYgRkbVkCjOxTxP-8ChAzFuMigGCw==';
        
        let currentRoom = 'LD5RU'; // Default room
        let isUIVisible = true;
        let isUICollapsed = false;
        
        // Function to get room from URL parameters or use default
        function getRoomFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomParam = urlParams.get('room');
            if (roomParam) return roomParam.toUpperCase();
            
            const hash = window.location.hash.substring(1);
            const hashParams = new URLSearchParams(hash);
            const roomHash = hashParams.get('room');
            if (roomHash) return roomHash.toUpperCase();
            
            return 'LD5RU'; // Default fallback
        }
        
        function buildAPIURL(room) {
            return `${API_BASE_URL}${room}?code=${API_CODE}`;
        }

        // --- Room Selector UI Functions ---
        function showRoomStatus(message, type) {
            let fullMessage = message;
            if (type === 'loading') {
                fullMessage = `<span class="spinner"></span> ${message}`;
                roomStatusMessage.innerHTML = fullMessage;
            } else {
                roomStatusMessage.textContent = message;
            }
            roomStatusMessage.className = `room-status ${type}`;
            roomStatusMessage.style.display = 'flex'; // Use flex for spinner alignment
            
            if (type !== 'loading') {
                setTimeout(() => {
                    // Only hide if the status hasn't changed (e.g. from error to new loading)
                    if (roomStatusMessage.classList.contains(type)) {
                         roomStatusMessage.style.display = 'none';
                    }
                }, 5000);
            }
        }

        function updateCurrentRoomDisplayInUI(room) {
            currentRoomDisplay.textContent = room;
            roomCodeInput.value = room; // Keep input in sync
        }

        function toggleUIMinimize() {
            isUICollapsed = !isUICollapsed;
            roomSelectorUI.classList.toggle('collapsed', isUICollapsed);
            minimizeBtn.textContent = isUICollapsed ? '+' : '‚àí';
        }

        function hideRoomSelectorHTMLUI() {
            if (!isUIVisible) return;
            roomSelectorUI.classList.add('hidden');
            isUIVisible = false;
        }

        function showRoomSelectorHTMLUI() {
            if (isUIVisible && !roomSelectorUI.classList.contains('hidden')) return;
            roomSelectorUI.classList.remove('hidden');
            isUIVisible = true;
        }
        
        minimizeBtn.addEventListener('click', toggleUIMinimize);
        roomSelectorUI.addEventListener('click', (e) => {
            if (isUICollapsed && (e.target === roomSelectorUI || e.target === currentRoomDisplay || e.target.parentNode === currentRoomDisplay)) {
                toggleUIMinimize();
            }
        });

        connectRoomBtn.addEventListener('click', () => {
            const newRoom = roomCodeInput.value.trim().toUpperCase();
            if (newRoom && newRoom !== currentRoom) {
                connectToRoom(newRoom);
            } else if (newRoom === currentRoom) {
                showRoomStatus('J√° conectado a esta sala.', 'loading'); // Use loading style for info
                 setTimeout(() => showRoomStatus('', ''), 100); // Clear quickly
            } else if (!newRoom) {
                showRoomStatus('Por favor, insira um c√≥digo de sala.', 'error');
            }
        });

        roomCodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                connectRoomBtn.click();
            }
        });

        async function connectToRoom(room) {
            connectRoomBtn.disabled = true;
            roomCodeInput.disabled = true;
            const originalButtonText = connectRoomBtn.textContent;
            connectRoomBtn.innerHTML = '<span class="spinner"></span> Conectando';

            showRoomStatus(`Conectando √† sala ${room}...`, 'loading');
            
            const newUrl = new URL(window.location);
            newUrl.searchParams.set('room', room);
            window.history.pushState({ room: room }, '', newUrl);
            
            currentRoom = room; // Update global currentRoom

            const success = await initializeApp(); // initializeApp will use 'currentRoom'

            connectRoomBtn.disabled = false;
            roomCodeInput.disabled = false;
            connectRoomBtn.innerHTML = originalButtonText; // Restore button text

            if (success) {
                updateCurrentRoomDisplayInUI(room);
                // showRoomStatus(`Conectado: ${room}`, 'success'); // initializeApp handles this
            } else {
                // showRoomStatus(`Falha ao conectar: ${room}`, 'error'); // initializeApp handles this
                if (isUICollapsed) toggleUIMinimize();
                showRoomSelectorHTMLUI();
                roomCodeInput.focus();
            }
        }

        // --- Fullscreen/VR UI Hiding ---
        function handleModeChange(isImmersive) {
            if (isImmersive) {
                hideRoomSelectorHTMLUI();
            } else {
                showRoomSelectorHTMLUI();
            }
        }
        document.addEventListener('fullscreenchange', () => handleModeChange(!!document.fullscreenElement));
        document.addEventListener('webkitfullscreenchange', () => handleModeChange(!!document.webkitFullscreenElement));
        document.addEventListener('mozfullscreenchange', () => handleModeChange(!!document.mozFullScreenElement));
        document.addEventListener('MSFullscreenChange', () => handleModeChange(!!document.msFullscreenElement));
        
        const sceneEl = document.querySelector('a-scene');
        sceneEl.addEventListener('enter-vr', () => handleModeChange(true));
        sceneEl.addEventListener('exit-vr', () => handleModeChange(false));


        // --- A-Frame Indicator Functions ---
        function showLoadingIndicator(show, roomName = '') {
            loadingIndicatorEl.setAttribute('visible', show);
            if (show) {
                roomInfoTextEl.setAttribute('value', roomName ? `Sala: ${roomName}` : 'Carregando...');
            }
        }

        function showErrorIndicator(show, mainMsg, subMsg, showRetryOpt) {
            errorIndicatorEl.setAttribute('visible', show);
            if (show) {
                errorMainTextEl.setAttribute('value', mainMsg);
                errorSubTextEl.setAttribute('value', subMsg);
                retryTextEl.setAttribute('visible', showRetryOpt);
                if (showRetryOpt) {
                    // Clone and replace to remove old listeners and ensure it's fresh
                    const newRetryText = retryTextEl.cloneNode(true);
                    newRetryText.setAttribute('value', "Clique aqui para tentar novamente");
                    retryTextEl.parentNode.replaceChild(newRetryText, retryTextEl);
                    newRetryText.addEventListener('click', handleClickRetryAFRAME, { once: true });
                    // Update global reference if needed, or always query by ID
                    // retryTextEl = newRetryText; // This won't work as retryTextEl is const
                }
            }
        }
        
        function handleClickRetryAFRAME() {
            document.getElementById('retry-text').setAttribute('value', "Tentando novamente...");
            initializeApp();
        }

        // --- Chart Logic (from user's second script block) ---
        const POSITION_CONFIG = { startX: -18, baseY: 1.5, baseZ: 12, spacingX: 12, pieOffsetY: 3 };
        const TIME_TYPES = {
            'years': { label: 'Anos', next: 'months' },
            'months': { label: 'Meses', next: 'days' },
            'days': { label: 'Dias', next: 'years' }
        };
        const JSON_TIME_MAPPING = {
            'Year': 'years', 'Month': 'months', 'Day': 'days',
            'year': 'years', 'month': 'months', 'day': 'days',
            'years': 'years', 'months': 'months', 'days': 'days'
        };
        let chartsData = [];
        let configurationsData = null;
        let chartStates = {};

        function processKPIData(kpihistory, targetKPIId, timeAxisType, valueType = 'NewValue_1') {
            const kpiData = kpihistory.filter(item => item.KPIId == targetKPIId);
            const dataByTimeKey = {};
            kpiData.forEach(item => {
                const date = new Date(item.ChangedAt);
                let timeKey;
                if (timeAxisType === 'years') timeKey = date.getFullYear().toString();
                else if (timeAxisType === 'months') timeKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                else if (timeAxisType === 'days') timeKey = date.toISOString().split('T')[0];
                else timeKey = date.getFullYear().toString();
                if (!dataByTimeKey[timeKey]) dataByTimeKey[timeKey] = [];
                dataByTimeKey[timeKey].push({ ...item, parsedDate: date });
            });
            const finalData = [];
            Object.keys(dataByTimeKey).sort().forEach(timeKey => {
                const sortedItems = dataByTimeKey[timeKey].sort((a, b) => b.parsedDate - a.parsedDate);
                const mostRecent = sortedItems[0];
                const value = valueType === 'NewValue_2' ? mostRecent.NewValue_2 : mostRecent.NewValue_1;
                finalData.push({ key: timeKey, height: parseFloat(value) || 0 });
            });
            return finalData;
        }

        function processPieData(kpihistory, targetKPIId, timeAxisType, valueType = 'NewValue_1') {
            const baseData = processKPIData(kpihistory, targetKPIId, timeAxisType, valueType);
            return baseData.map(item => ({ key: item.key, size: item.height }));
        }

        function hasValidData(kpihistory, targetKPIId, valueType) {
            const kpiData = kpihistory.filter(item => item.KPIId == targetKPIId);
            return kpiData.some(item => {
                const value = valueType === 'NewValue_2' ? item.NewValue_2 : item.NewValue_1;
                return value != null && value !== undefined && parseFloat(value) !== 0;
            });
        }

        function calculatePosition(chartIndex, isPieChart = false) {
            const x = POSITION_CONFIG.startX + (chartIndex * POSITION_CONFIG.spacingX);
            const y = POSITION_CONFIG.baseY + (isPieChart ? POSITION_CONFIG.pieOffsetY : 0);
            const z = POSITION_CONFIG.baseZ;
            return `${x} ${y} ${z}`;
        }

        function toggleChartValue(chartIndex) {
            const state = chartStates[chartIndex];
            if (!state) return;
            state.valueType = state.valueType === 'NewValue_1' ? 'NewValue_2' : 'NewValue_1';
            renderSingleChart(chartIndex);
        }

        function toggleChartTimeType(chartIndex) {
            const state = chartStates[chartIndex];
             if (!state) return;
            state.timeType = TIME_TYPES[state.timeType].next;
            renderSingleChart(chartIndex);
        }
        
        function renderSingleChart(chartIndex) {
            const chartConfig = chartsData.find(c => c.originalIndex === chartIndex); // Find by original index
            const state = chartStates[chartIndex];
            if (!chartConfig || !state) {
                console.warn("Chart config or state not found for index:", chartIndex);
                return;
            }

            const existingChart = chartsRoot.querySelector(`[data-chart-original-index="${chartIndex}"]`);
            const existingButtons = chartsRoot.querySelector(`[data-buttons-original-index="${chartIndex}"]`);

            if (existingChart) {
                if (chartConfig.chart.chartType === "pizza") {
                    if (existingChart.components && existingChart.components['babia-pie']) {
                        existingChart.removeAttribute('babia-pie'); // Important for babia components
                    }
                }
                 // Generic removal after a short delay if needed, or direct
                setTimeout(() => {
                    if (existingChart.parentNode) existingChart.parentNode.removeChild(existingChart);
                }, 10); // Small delay for component cleanup
            }
            if (existingButtons && existingButtons.parentNode) {
                existingButtons.parentNode.removeChild(existingButtons);
            }
            
            // Re-create after a delay
            setTimeout(() => {
                const chartEl = createChart(chartConfig, chartConfig.displayIndex, state.valueType, state.timeType); // Use displayIndex for positioning
                chartsRoot.appendChild(chartEl);
                const buttonsEl = createChartButtons(chartConfig.originalIndex, chartConfig.displayIndex, state); // Pass originalIndex for state, displayIndex for pos
                chartsRoot.appendChild(buttonsEl);
            }, 50);
        }

        function createChartButtons(originalChartIndex, displayChartIndex, state) {
            const chartConfig = chartsData.find(c => c.originalIndex === originalChartIndex);
            if (!chartConfig) return document.createElement('a-entity'); // Return empty if no config

            const position = calculatePosition(displayChartIndex, false);
            const [x, y, z] = position.split(' ').map(parseFloat);
            const kpiId = parseInt(chartConfig.chart.zAxis);
            const hasValue1 = hasValidData(chartConfig.kpihistory, kpiId, 'NewValue_1');
            const hasValue2 = hasValidData(chartConfig.kpihistory, kpiId, 'NewValue_2');
            const hasBothValues = hasValue1 && hasValue2;
            
            const buttonsContainer = document.createElement('a-entity');
            buttonsContainer.setAttribute('position', `${x + 6} ${y + 8} ${z}`);
            buttonsContainer.setAttribute('data-buttons-original-index', originalChartIndex);
            let buttonVerticalOffset = 0;

            if (hasBothValues) {
                const valueButton = document.createElement('a-entity');
                const valueLabel = state.valueType === 'NewValue_1' ? 'Produto 1' : 'Produto 2';
                valueButton.setAttribute('geometry', 'primitive: box; width: 2.5; height: 0.8; depth: 0.1');
                valueButton.setAttribute('material', `color: ${state.valueType === 'NewValue_1' ? '#4CAF50' : '#FF9800'}`);
                valueButton.setAttribute('position', `0 ${buttonVerticalOffset} 0`);
                valueButton.innerHTML = `<a-text value="${valueLabel}" position="0 0 0.06" align="center" color="white" width="4"></a-text>`;
                valueButton.classList.add('clickable');
                valueButton.addEventListener('click', (e) => { e.stopPropagation(); setTimeout(() => toggleChartValue(originalChartIndex), 50); });
                buttonsContainer.appendChild(valueButton);
                buttonVerticalOffset -= 1.2;
            }

            const timeButton = document.createElement('a-entity');
            timeButton.setAttribute('geometry', 'primitive: box; width: 2.5; height: 0.8; depth: 0.1');
            timeButton.setAttribute('material', 'color: #2196F3');
            timeButton.setAttribute('position', `0 ${buttonVerticalOffset} 0`);
            timeButton.innerHTML = `<a-text value="${TIME_TYPES[state.timeType].label}" position="0 0 0.06" align="center" color="white" width="4"></a-text>`;
            timeButton.classList.add('clickable');
            timeButton.addEventListener('click', (e) => { e.stopPropagation(); setTimeout(() => toggleChartTimeType(originalChartIndex), 50); });
            buttonsContainer.appendChild(timeButton);
            return buttonsContainer;
        }

        function createChart(chartConfig, displayChartIndex, valueType, timeType = 'years') {
            const { kpihistory, chart, originalIndex } = chartConfig;
            const kpiId = parseInt(chart.zAxis);
            const chartContainer = document.createElement('a-entity');
            const isPieChart = chart.chartType === "pizza";
            chartContainer.setAttribute('position', calculatePosition(displayChartIndex, isPieChart));
            chartContainer.setAttribute('data-chart-original-index', originalIndex); // Store original index
            
            const palette = valueType === 'NewValue_1' ? 'commerce' : 'ubuntu';
            const productName = valueType === 'NewValue_1' ? 'Produto 1' : 'Produto 2';
            const timeLabel = TIME_TYPES[timeType].label;
            const chartTitle = `${chart.graphname} (${productName} - ${timeLabel})`;

            if (chart.chartType === "barras") {
                const data = processKPIData(kpihistory, kpiId, timeType, valueType);
                chartContainer.setAttribute('babia-bars', `legend: true; axis: true; palette: ${palette}; tooltip: true; animation: true; title: ${chartTitle}; titleColor: #FFFFFF; titleFont: #optimerBoldFont; titlePosition: 2 12 0; heightMax: 800; x_axis: key; height: height; data: ${JSON.stringify(data)}; showInfo: true; showInfoColor: #FFFFFF`);
            } else if (chart.chartType === "pizza") {
                let data = processPieData(kpihistory, kpiId, timeType, valueType);
                if (data.length === 0 || data.every(item => item.size === 0)) {
                    data = [{ key: 'Sem Dados', size: 1 }];
                }
                const titleEl = document.createElement('a-text');
                titleEl.setAttribute('value', chartTitle);
                titleEl.setAttribute('position', '1 6 0');
                titleEl.setAttribute('align', 'center');
                titleEl.setAttribute('color', '#FFFFFF');
                titleEl.setAttribute('width', '8');
                chartContainer.appendChild(titleEl);
                
                const pieEl = document.createElement('a-entity');
                pieEl.setAttribute('babia-pie', `legend: true; palette: ${palette}; animation: false; key: key; size: size; data: ${JSON.stringify(data)}; showInfo: true; showInfoColor: #FFFFFF`);
                pieEl.setAttribute('rotation', '90 0 0');
                pieEl.setAttribute('scale', '1.8 1.8 1.8');
                chartContainer.appendChild(pieEl);
            }
            return chartContainer;
        }

        function clearCharts() {
            while (chartsRoot.firstChild) {
                chartsRoot.removeChild(chartsRoot.firstChild);
            }
        }
        
        function getDefaultTimeType(chart) {
            const checkProps = ['xAxis', 'timeUnit', 'xAxisUnit', 'temporalUnit'];
            for (const prop of checkProps) {
                if (chart[prop]) {
                    const mappedType = JSON_TIME_MAPPING[chart[prop]];
                    if (mappedType) return mappedType;
                }
            }
            return 'years';
        }

        function initializeChartStates() {
            chartStates = {};
            chartsData.forEach((chartConfig) => { // Use chartConfig.originalIndex
                const originalIndex = chartConfig.originalIndex;
                const defaultTimeType = getDefaultTimeType(chartConfig.chart);
                const kpiId = parseInt(chartConfig.chart.zAxis);
                const hasValue1 = hasValidData(chartConfig.kpihistory, kpiId, 'NewValue_1');
                const hasValue2 = hasValidData(chartConfig.kpihistory, kpiId, 'NewValue_2');
                let defaultValueType = (hasValue1 || !hasValue2) ? 'NewValue_1' : 'NewValue_2';
                chartStates[originalIndex] = { valueType: defaultValueType, timeType: defaultTimeType };
            });
        }

        function renderAllCharts() {
            clearCharts();
            let displayIndex = 0;
            chartsData.forEach((chartConfig) => {
                const { kpihistory, chart, originalIndex } = chartConfig;
                const kpiId = parseInt(chart.zAxis);
                if (hasValidData(kpihistory, kpiId, 'NewValue_1') || hasValidData(kpihistory, kpiId, 'NewValue_2')) {
                    const state = chartStates[originalIndex];
                    // Auto-switch value type if current one has no data but other does
                    if (state.valueType === 'NewValue_1' && !hasValidData(kpihistory, kpiId, 'NewValue_1') && hasValidData(kpihistory, kpiId, 'NewValue_2')) {
                        state.valueType = 'NewValue_2';
                    } else if (state.valueType === 'NewValue_2' && !hasValidData(kpihistory, kpiId, 'NewValue_2') && hasValidData(kpihistory, kpiId, 'NewValue_1')) {
                        state.valueType = 'NewValue_1';
                    }
                    chartConfig.displayIndex = displayIndex; // Store display index for positioning
                    const chartEl = createChart(chartConfig, displayIndex, state.valueType, state.timeType);
                    chartsRoot.appendChild(chartEl);
                    const buttonsEl = createChartButtons(originalIndex, displayIndex, state);
                    chartsRoot.appendChild(buttonsEl);
                    displayIndex++;
                }
            });
        }

        async function fetchDataFromAPI(room, retries = 2) { // Reduced retries for faster feedback
            const apiUrl = buildAPIURL(room);
            console.log(`Fetching data from API: ${apiUrl}`);
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    const response = await fetch(apiUrl, { headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }});
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                    const data = await response.json();
                    if (!Array.isArray(data) || data.length === 0 || !data[0].config || !data[0].config.kpihistory || !data[0].config.charts) {
                        throw new Error('Formato de dados inv√°lido ou vazio recebido da API.');
                    }
                    return data;
                } catch (error) {
                    console.error(`Tentativa ${attempt} falhou: ${error.message}`);
                    if (attempt === retries) throw error;
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Exponential backoff
                }
            }
        }

        // --- Main Application Initialization ---
        async function initializeApp() {
            // currentRoom is already set by getRoomFromURL or connectToRoom
            updateCurrentRoomDisplayInUI(currentRoom);
            
            showLoadingIndicator(true, currentRoom);
            showErrorIndicator(false);
            clearCharts();
            showRoomStatus(`Carregando sala: ${currentRoom}...`, 'loading');

            try {
                const apiData = await fetchDataFromAPI(currentRoom);
                configurationsData = apiData;
                chartsData = []; // Reset chartsData
                let originalIdx = 0;
                apiData.forEach(config => {
                    config.config.charts.forEach(chart => {
                        chartsData.push({ kpihistory: config.config.kpihistory, chart: chart, originalIndex: originalIdx++ });
                    });
                });

                if (chartsData.length === 0) throw new Error('Nenhum gr√°fico encontrado nos dados da sala.');
                
                initializeChartStates();
                renderAllCharts();
                showLoadingIndicator(false);
                showRoomStatus(`Conectado √† sala: ${currentRoom}`, 'success');
                console.log(`Aplica√ß√£o inicializada para a sala: ${currentRoom}`);
                return true; // Success
            } catch (error) {
                console.error('Falha ao inicializar aplica√ß√£o:', error);
                showLoadingIndicator(false);
                showErrorIndicator(true, "O carregamento da sala falhou", `Erro: ${error.message}. Verifique o c√≥digo e tente novamente.`, true);
                showRoomStatus(`Falha: ${error.message}`, 'error');
                return false; // Failure
            }
        }

        // --- Initial Load ---
        window.addEventListener('load', () => {
            currentRoom = getRoomFromURL(); // Initialize currentRoom from URL/default
            roomCodeInput.value = currentRoom; // Set input field value
            updateCurrentRoomDisplayInUI(currentRoom); // Set collapsed UI display

            // Check if A-Frame scene is already loaded, otherwise wait
            if (sceneEl.hasLoaded) {
                initializeApp();
            } else {
                sceneEl.addEventListener('loaded', initializeApp, { once: true });
            }
        });

        window.addEventListener('popstate', (event) => {
            const roomFromHistory = getRoomFromURL();
            if (roomFromHistory !== currentRoom) {
                console.log(`Navega√ß√£o para sala: ${roomFromHistory}`);
                currentRoom = roomFromHistory;
                // No need to pushState again, just re-initialize
                initializeApp();
            }
        });

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BabiaXR - Gráfico 3D</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.3/dist/aframe-environment-component.min.js"></script>
    <script src="https://unpkg.com/aframe-text-geometry-component@0.5.1/dist/aframe-text-geometry-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/babiaxr/aframe-babia-components@master/dist/aframe-babia-components.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/babiaxr/aframe-babia-components@master/dist/aframe-babia-ui.min.js"></script>
    <style>
        #fallback-ui {
            display: none; /* Initially hidden */
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: rgba(40, 40, 40, 0.85);
            padding: 20px;
            border-radius: 10px;
            color: #f0f0f0;
            font-family: Arial, sans-serif;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            max-width: 350px; /* Prevent it from being too wide */
        }

        #fallback-ui.visible {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        #fallback-ui p {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            line-height: 1.4;
        }

        #fallback-ui label {
            font-size: 14px;
            margin-right: 8px;
            display: block;
            margin-bottom: 5px;
        }

        #fallback-ui input[type="text"] {
            padding: 8px 10px;
            border: 1px solid #555;
            background-color: #333;
            color: #f0f0f0;
            border-radius: 5px;
            font-size: 14px;
            width: calc(100% - 22px); /* Full width minus padding */
            margin-bottom: 10px;
        }

        #fallback-ui button {
            padding: 10px 18px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.2s ease;
            width: 100%; /* Full width button */
        }

        #fallback-ui button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <a-scene background="color: #ECECEC">
        <a-entity environment="preset: default; groundColor: #445; groundTexture: walk;"></a-entity>
        
        <a-assets>
            <a-asset-item id="optimerBoldFont" src="https://rawgit.com/mrdoob/three.js/dev/examples/fonts/optimer_bold.typeface.json"></a-asset-item>
        </a-assets>

        <!-- Loading indicator -->
        <a-entity id="loading-indicator" position="0 3 -5">
            <a-text value="Loading data..." align="center" color="#FFFFFF" width="8"></a-text>
            <a-text id="room-info" value="" position="0 -1 0" align="center" color="#CCCCCC" width="6"></a-text>
        </a-entity>

        <!-- Error indicator -->
        <a-entity id="error-indicator" position="0 3 -5" visible="false">
            <a-text id="error-text-vr" value="Error loading data" align="center" color="#FF0000" width="8"></a-text>
        </a-entity>

        <!-- Ponto de inserção de gráficos -->
        <a-entity id="charts-root"></a-entity>

        <!-- Câmera -->
        <a-entity movement-controls="fly: true" position="-3 5 20">
            <a-entity camera position="0 0 0" look-controls></a-entity>
            <a-entity cursor="rayOrigin:mouse" raycaster></a-entity>
            <a-entity laser-controls="hand: right"></a-entity>
        </a-entity>
    </a-scene>

    <!-- Fallback UI for room change -->
    <div id="fallback-ui">
        <p id="fallback-message-text">O carregamento da sala falhou.</p>
        <div>
            <label for="room-input-fallback">ID da Sala:</label>
            <input type="text" id="room-input-fallback" placeholder="Ex: LD5RU">
            <button id="change-room-button">Carregar Sala</button>
        </div>
    </div>

    <script>
        const root = document.getElementById('charts-root');
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorIndicator = document.getElementById('error-indicator');

        // API Configuration
        const API_BASE_URL = 'https://modsi-api-ffhhfgecfdehhscv.spaincentral-01.azurewebsites.net/api/Room/Get/';
        const API_CODE = 'z4tKbNFdaaXzHZ4ayn9pRQokNWYgRkbVkCjOxTxP-8ChAzFuMigGCw==';
        
        let isErrorFallbackActive = false;

        // Function to update fallback UI visibility based on error state and presentation mode
        function updateFallbackUIVisibility() {
            const fallbackUI = document.getElementById('fallback-ui');
            const sceneEl = document.querySelector('a-scene');
            if (!fallbackUI || !sceneEl || !sceneEl.hasLoaded) return; // Ensure scene is loaded

            if (isErrorFallbackActive) {
                const isInPresentationMode = sceneEl.is('vr-mode') || 
                                           (document.fullscreenElement && 
                                            (document.fullscreenElement === sceneEl.canvas || (sceneEl.canvas && sceneEl.canvas.contains(document.fullscreenElement))));
                if (isInPresentationMode) {
                    fallbackUI.classList.remove('visible');
                } else {
                    fallbackUI.classList.add('visible');
                }
            } else {
                fallbackUI.classList.remove('visible');
            }
        }
        
        // Function to get room from URL parameters
        function getRoomFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomParam = urlParams.get('room');
            
            if (roomParam) {
                console.log(`Room parameter found: ${roomParam}`);
                return roomParam;
            }
            
            const hash = window.location.hash.substring(1);
            const hashParams = new URLSearchParams(hash);
            const roomHash = hashParams.get('room');
            
            if (roomHash) {
                console.log(`Room hash found: ${roomHash}`);
                return roomHash;
            }
            
            console.log('No room parameter found, using default: LD5RU');
            return 'LD5RU';
        }
        
        function buildAPIURL(room) {
            return `${API_BASE_URL}${room}?code=${API_CODE}`;
        }

        const POSITION_CONFIG = {
            startX: -18, baseY: 1.5, baseZ: 12, spacingX: 12, pieOffsetY: 3
        };

        const TIME_TYPES = {
            'years': { label: 'Anos', next: 'months' },
            'months': { label: 'Meses', next: 'days' },
            'days': { label: 'Dias', next: 'years' }
        };

        const JSON_TIME_MAPPING = {
            'Year': 'years', 'Month': 'months', 'Day': 'days',
            'year': 'years', 'month': 'months', 'day': 'days',
            'years': 'years', 'months': 'months', 'days': 'days'
        };

        let chartsData = [];
        let configurationsData = null;
        let chartStates = {};

        function processKPIData(kpihistory, targetKPIId, timeAxisType, valueType = 'NewValue_1') {
            const kpiData = kpihistory.filter(item => item.KPIId == targetKPIId);
            const dataByYear = {};
            kpiData.forEach(item => {
                const date = new Date(item.ChangedAt);
                let timeKey;
                if (timeAxisType === 'years') timeKey = date.getFullYear().toString();
                else if (timeAxisType === 'months') timeKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                else if (timeAxisType === 'days') timeKey = date.toISOString().split('T')[0];
                else timeKey = date.getFullYear().toString();
                if (!dataByYear[timeKey]) dataByYear[timeKey] = [];
                dataByYear[timeKey].push({ ...item, parsedDate: date });
            });
            const finalData = [];
            Object.keys(dataByYear).sort().forEach(timeKey => {
                const sortedItems = dataByYear[timeKey].sort((a, b) => b.parsedDate - a.parsedDate);
                const mostRecent = sortedItems[0];
                const value = valueType === 'NewValue_2' ? mostRecent.NewValue_2 : mostRecent.NewValue_1;
                finalData.push({ key: timeKey, height: parseFloat(value) || 0 });
            });
            return finalData;
        }

        function processPieData(kpihistory, targetKPIId, timeAxisType, valueType = 'NewValue_1') {
            const baseData = processKPIData(kpihistory, targetKPIId, timeAxisType, valueType);
            return baseData.map(item => ({ key: item.key, size: item.height }));
        }

        function hasValidData(kpihistory, targetKPIId, valueType) {
            const kpiData = kpihistory.filter(item => item.KPIId == targetKPIId);
            return kpiData.some(item => {
                const value = valueType === 'NewValue_2' ? item.NewValue_2 : item.NewValue_1;
                return value != null && value !== undefined && parseFloat(value) !== 0;
            });
        }

        function calculatePosition(chartIndex, isPieChart = false) {
            const x = POSITION_CONFIG.startX + (chartIndex * POSITION_CONFIG.spacingX);
            const y = POSITION_CONFIG.baseY + (isPieChart ? POSITION_CONFIG.pieOffsetY : 0);
            const z = POSITION_CONFIG.baseZ;
            return `${x} ${y} ${z}`;
        }

        function toggleChartValue(chartIndex) {
            const state = chartStates[chartIndex];
            state.valueType = state.valueType === 'NewValue_1' ? 'NewValue_2' : 'NewValue_1';
            renderSingleChart(chartIndex);
        }

        function toggleChartTimeType(chartIndex) {
            const state = chartStates[chartIndex];
            state.timeType = TIME_TYPES[state.timeType].next;
            renderSingleChart(chartIndex);
        }

        function renderSingleChart(chartIndex) {
            const chartConfig = chartsData[chartIndex];
            const state = chartStates[chartIndex];
            if (!chartConfig || !state) return;

            const existingChart = root.querySelector(`[data-chart-index="${chartIndex}"]`);
            const existingButtons = root.querySelector(`[data-buttons-index="${chartIndex}"]`);

            if (existingChart) {
                if (chartConfig.chart.chartType === "pizza") {
                    if (existingChart.components && existingChart.components['babia-pie']) {
                        existingChart.removeAttribute('babia-pie');
                    }
                    setTimeout(() => {
                        if (existingChart.parentNode) existingChart.parentNode.removeChild(existingChart);
                    }, 50);
                } else {
                    root.removeChild(existingChart);
                }
            }
            if (existingButtons && existingButtons.parentNode) existingButtons.parentNode.removeChild(existingButtons);

            setTimeout(() => {
                const chartEl = createChart(chartConfig, chartIndex, state.valueType, state.timeType);
                root.appendChild(chartEl);
                const buttonsEl = createChartButtons(chartIndex, state);
                root.appendChild(buttonsEl);
            }, chartConfig.chart.chartType === "pizza" ? 100 : 50);
        }

        function createChartButtons(chartIndex, state) {
            const chartConfig = chartsData[chartIndex];
            const position = calculatePosition(chartIndex, false);
            const [x, y, z] = position.split(' ').map(parseFloat);
            const kpiId = parseInt(chartConfig.chart.zAxis);
            const hasValue1 = hasValidData(chartConfig.kpihistory, kpiId, 'NewValue_1');
            const hasValue2 = hasValidData(chartConfig.kpihistory, kpiId, 'NewValue_2');
            const hasBothValues = hasValue1 && hasValue2;
            
            const buttonsContainer = document.createElement('a-entity');
            buttonsContainer.setAttribute('position', `${x + 6} ${y + 8} ${z}`);
            buttonsContainer.setAttribute('data-buttons-index', chartIndex);
            let buttonVerticalOffset = 0;

            if (hasBothValues) {
                const valueButton = document.createElement('a-entity');
                const valueLabel = state.valueType === 'NewValue_1' ? 'Produto 1' : 'Produto 2';
                const valueColor = state.valueType === 'NewValue_1' ? '#4CAF50' : '#FF9800';
                valueButton.setAttribute('geometry', 'primitive: box; width: 2.5; height: 0.8; depth: 0.1');
                valueButton.setAttribute('material', `color: ${valueColor}`);
                valueButton.setAttribute('position', `0 ${buttonVerticalOffset} 0`);
                const valueText = document.createElement('a-text');
                valueText.setAttribute('value', valueLabel);
                valueText.setAttribute('position', '0 0 0.06');
                valueText.setAttribute('align', 'center'); valueText.setAttribute('color', 'white'); valueText.setAttribute('width', '4');
                valueButton.appendChild(valueText);
                valueButton.setAttribute('class', 'clickable');
                valueButton.setAttribute('data-chart-index', chartIndex); valueButton.setAttribute('data-button-type', 'value');
                valueButton.addEventListener('click', (event) => {
                    event.stopPropagation(); setTimeout(() => toggleChartValue(chartIndex), 100);
                });
                buttonsContainer.appendChild(valueButton);
                buttonVerticalOffset -= 1.2;
            }

            const timeButton = document.createElement('a-entity');
            const timeLabel = TIME_TYPES[state.timeType].label;
            timeButton.setAttribute('geometry', 'primitive: box; width: 2.5; height: 0.8; depth: 0.1');
            timeButton.setAttribute('material', 'color: #2196F3');
            timeButton.setAttribute('position', `0 ${buttonVerticalOffset} 0`);
            const timeText = document.createElement('a-text');
            timeText.setAttribute('value', timeLabel);
            timeText.setAttribute('position', '0 0 0.06');
            timeText.setAttribute('align', 'center'); timeText.setAttribute('color', 'white'); timeText.setAttribute('width', '4');
            timeButton.appendChild(timeText);
            timeButton.setAttribute('class', 'clickable');
            timeButton.setAttribute('data-chart-index', chartIndex); timeButton.setAttribute('data-button-type', 'time');
            timeButton.addEventListener('click', (event) => {
                event.stopPropagation(); setTimeout(() => toggleChartTimeType(chartIndex), 100);
            });
            buttonsContainer.appendChild(timeButton);
            return buttonsContainer;
        }

        function createChart(chartConfig, chartIndex, valueType, timeType = 'years') {
            const { kpihistory, chart } = chartConfig;
            const kpiId = parseInt(chart.zAxis);
            const chartContainer = document.createElement('a-entity');
            const isPieChart = chart.chartType === "pizza";
            const position = calculatePosition(chartIndex, isPieChart);
            chartContainer.setAttribute('position', position);
            chartContainer.setAttribute('data-chart-index', chartIndex);
            const palette = valueType === 'NewValue_1' ? 'commerce' : 'ubuntu';
            const productName = valueType === 'NewValue_1' ? 'Produto 1' : 'Produto 2';
            const timeLabel = TIME_TYPES[timeType].label;

            if (chart.chartType === "barras") {
                const chartData = processKPIData(kpihistory, kpiId, timeType, valueType);
                const babiaConfig = {
                    legend: true, axis: true, palette: palette, tooltip: true, animation: true,
                    title: `${chart.graphname} (${productName} - ${timeLabel})`, titleColor: '#FFFFFF',
                    titleFont: '#optimerBoldFont', titlePosition: '2 12 0', heightMax: 800,
                    x_axis: 'key', height: 'height', data: JSON.stringify(chartData),
                    showInfo: true, showInfoColor: '#FFFFFF'
                };
                chartContainer.setAttribute('babia-bars', Object.entries(babiaConfig).map(([k, v]) => `${k}: ${v}`).join('; '));
            } else if (chart.chartType === "pizza") {
                let pieData = processPieData(kpihistory, kpiId, timeType, valueType);
                if (pieData.length === 0 || pieData.every(item => item.size === 0)) {
                    console.warn(`Não há dados válidos para o gráfico pie ${chart.graphname}`);
                    pieData.push({ key: 'Sem Dados', size: 1 });
                }
                const titleEl = document.createElement('a-text');
                titleEl.setAttribute('value', `${chart.graphname} (${productName} - ${timeLabel})`);
                titleEl.setAttribute('position', '1 6 0'); titleEl.setAttribute('align', 'center');
                titleEl.setAttribute('color', '#FFFFFF'); titleEl.setAttribute('width', '8');
                chartContainer.appendChild(titleEl);
                const pieEl = document.createElement('a-entity');
                const pieConfig = {
                    legend: true, palette: palette, animation: false, key: 'key', size: 'size',
                    data: JSON.stringify(pieData), showInfo: true, showInfoColor: '#FFFFFF'
                };
                pieEl.setAttribute('babia-pie', Object.entries(pieConfig).map(([k, v]) => `${k}: ${v}`).join('; '));
                pieEl.setAttribute('rotation', '90 0 0'); pieEl.setAttribute('scale', '1.8 1.8 1.8');
                chartContainer.appendChild(pieEl);
            }
            return chartContainer;
        }

        function clearCharts() {
            while (root.firstChild) root.removeChild(root.firstChild);
        }

        function getDefaultTimeType(chart) {
            if (chart.xAxis) { const mappedType = JSON_TIME_MAPPING[chart.xAxis]; if (mappedType) return mappedType; }
            if (chart.timeUnit) { const mappedType = JSON_TIME_MAPPING[chart.timeUnit]; if (mappedType) return mappedType; }
            if (chart.xAxisUnit) { const mappedType = JSON_TIME_MAPPING[chart.xAxisUnit]; if (mappedType) return mappedType; }
            if (chart.temporalUnit) { const mappedType = JSON_TIME_MAPPING[chart.temporalUnit]; if (mappedType) return mappedType; }
            return 'years';
        }

        function initializeChartStates() {
            chartStates = {};
            chartsData.forEach((chartConfig, index) => {
                const defaultTimeType = getDefaultTimeType(chartConfig.chart);
                const kpiId = parseInt(chartConfig.chart.zAxis);
                const hasValue1 = hasValidData(chartConfig.kpihistory, kpiId, 'NewValue_1');
                const hasValue2 = hasValidData(chartConfig.kpihistory, kpiId, 'NewValue_2');
                let defaultValueType = 'NewValue_1';
                if (!hasValue1 && hasValue2) defaultValueType = 'NewValue_2';
                else if (hasValue1) defaultValueType = 'NewValue_1';
                chartStates[index] = { valueType: defaultValueType, timeType: defaultTimeType };
            });
        }

        function renderAllCharts() {
            clearCharts();
            let chartIndex = 0;
            chartsData.forEach((chartConfig, originalIndex) => {
                const { kpihistory, chart } = chartConfig;
                const kpiId = parseInt(chart.zAxis);
                const hasValue1 = hasValidData(kpihistory, kpiId, 'NewValue_1');
                const hasValue2 = hasValidData(kpihistory, kpiId, 'NewValue_2');
                if (hasValue1 || hasValue2) {
                    const state = chartStates[originalIndex];
                    if (state.valueType === 'NewValue_1' && !hasValue1 && hasValue2) state.valueType = 'NewValue_2';
                    else if (state.valueType === 'NewValue_2' && !hasValue2 && hasValue1) state.valueType = 'NewValue_1';
                    const el = createChart(chartConfig, chartIndex, state.valueType, state.timeType);
                    root.appendChild(el);
                    const buttonsEl = createChartButtons(chartIndex, state);
                    root.appendChild(buttonsEl);
                    chartIndex++;
                }
            });
        }

        function showLoading(show) {
            loadingIndicator.setAttribute('visible', show);
        }

        function showError(show, message = 'Error loading data') {
            errorIndicator.setAttribute('visible', show);
            if (show) {
                const errorTextVR = document.getElementById('error-text-vr');
                if (errorTextVR) errorTextVR.setAttribute('value', message);
            }
        }

        async function fetchDataFromAPI(retries = 3) {
            const room = getRoomFromURL();
            const apiUrl = buildAPIURL(room);
            console.log(`Using API URL: ${apiUrl}`);
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    console.log(`Fetching data (attempt ${attempt}/${retries}) for room: ${room}...`);
                    const response = await fetch(apiUrl, { method: 'GET', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' } });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                    const data = await response.json();
                    if (!Array.isArray(data) || data.length === 0) throw new Error('Invalid data format: expected non-empty array');
                    const firstItem = data[0];
                    if (!firstItem.config || !firstItem.config.kpihistory || !firstItem.config.charts) throw new Error('Invalid data structure: missing required properties');
                    return data;
                } catch (error) {
                    console.error(`Attempt ${attempt} failed:`, error.message);
                    if (attempt === retries) throw error;
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
        }

        async function initializeApp() {
            const fallbackUI = document.getElementById('fallback-ui');
            if (fallbackUI) fallbackUI.classList.remove('visible'); // Hide at start of attempt

            try {
                const room = getRoomFromURL();
                showLoading(true);
                showError(false); // Hide VR error message
                isErrorFallbackActive = false; // Assume success initially for this attempt
                updateFallbackUIVisibility(); // Ensure HTML fallback is hidden

                const roomInfo = document.getElementById('room-info');
                roomInfo.setAttribute('value', `Room: ${room}`);
                console.log('Initializing application...');
                
                const apiData = await fetchDataFromAPI();
                console.log('Data loaded successfully:', apiData);
                configurationsData = apiData;
                
                chartsData = [];
                apiData.forEach(config => {
                    const { kpihistory, charts } = config.config;
                    charts.forEach(chart => chartsData.push({ kpihistory: kpihistory, chart: chart }));
                });
                console.log('Charts data processed:', chartsData);
                
                if (chartsData.length === 0) throw new Error('No charts found in the data');
                
                initializeChartStates();
                console.log('Chart states initialized:', chartStates);
                showLoading(false);
                renderAllCharts();
                console.log(`Application initialized successfully for room: ${room}`);
                
            } catch (error) {
                console.error('Failed to initialize application:', error);
                showLoading(false);
                
                const currentRoom = getRoomFromURL() || "desconhecida";
                showError(true, `O carregamento da sala '${currentRoom}' falhou.\nUse o painel para tentar outra.`);
                
                isErrorFallbackActive = true;

                const fallbackMessageText = document.getElementById('fallback-message-text');
                const roomInputFallback = document.getElementById('room-input-fallback');
                const changeRoomButton = document.getElementById('change-room-button');

                if (fallbackUI && fallbackMessageText && roomInputFallback && changeRoomButton) {
                    fallbackMessageText.textContent = `Falha ao carregar dados para a sala '${currentRoom}'. Por favor, insira um novo ID de sala e tente novamente.`;
                    roomInputFallback.value = getRoomFromURL() || "";
                    
                    changeRoomButton.onclick = () => {
                        const newRoom = roomInputFallback.value.trim();
                        if (newRoom) {
                            const currentUrl = new URL(window.location.href);
                            currentUrl.searchParams.set('room', newRoom);
                            window.location.href = currentUrl.toString(); // Reload with new room
                        } else {
                            alert("Por favor, insira um ID de sala.");
                            roomInputFallback.focus();
                        }
                    };
                }
                updateFallbackUIVisibility(); // Show HTML fallback UI if not in VR/fullscreen
            }
        }

        window.addEventListener('load', () => {
            console.log('Page loaded, starting application...');
            initializeApp();

            const sceneEl = document.querySelector('a-scene');
            if (sceneEl) {
                sceneEl.addEventListener('loaded', () => { // Wait for A-Frame scene to be fully processed
                    console.log('A-Frame scene loaded');
                    updateFallbackUIVisibility(); // Initial check after scene is ready
                    sceneEl.addEventListener('enter-vr', updateFallbackUIVisibility);
                    sceneEl.addEventListener('exit-vr', updateFallbackUIVisibility);
                });
            }
            document.addEventListener('fullscreenchange', updateFallbackUIVisibility);
        });
    </script>
</body>
</html>
